< ------------------------------------------------------------JSP 시작하기 (Jasper란 알바생)------------------------------------------------------------>
* JSP 는 왜 쓸까?
	프로그램을 만들게되면 사용자에게 응답을 하며 결과물 돌려줌 > 웹문서
	간단하면 좋지만 보통 복잡한 형태의 html 구문을 이용해 결과물을 브라우저에게 보내줌
	서블릿에선 write함수로 한줄 한줄 한줄 다 수정해줘야함 >> 매우 노가다성
	
* Jasper의 역할
	out.write()로 감싸던 노가다성 서블릿코드를 간단히 바꿀수있게 해줌
	.jsp확장자를 붙이면 html내용들을 서블릿 출력 가능 형태로 바꿔줌

* 그럼 언제 출력할수있는 서블릿 코드 형태로 바꿔줄까?
	jsp가 요구될때(사용자가 jsp페이지를 요구할때) 바뀜
	따라서 URL매핑은 파일명 그대로 URL매핑됨 따라서 대문자보단 소문자가 좋음 (서블릿은 저장되어있는 파일명과 URL이 다르지만 JSP는 그렇지 않음)
	jasper가 add.jsp로 만드는 서블릿코드는 톰캣내부 경로에 add_jsp.java파일로 만든다.

* 서블릿과 다르게 jsp는 요청할 때마다 달라진게 있으면 알아서 다시 만들기 때문에 다시 서버를 시작할 필요가 없다.
	그리고 우리가 브라우저에서 보는 문서는 이클립스 파일이 아니라 톰캣의 홈 디렉토리로 배포해 브라우저에 띄운다.
	다만 실제 톰캣의 워크디렉토리가 아닌 이클립스가 관리하는 별도의 운영을 위한 사본을 만듦 (.metadata)

* 만약 jsp내부에 변수를 선언하고 싶었다
	int x = 3;
	int y = 4;
	>> jsp는 무조건 writer()로 붙여버린다.
	>> 코드 그대로 삽입하길 원하면 코드블럭을 붙여야함 <% 이 사이에 자바 코드 넣는다 %>	>> 서블릿을 jasper를 통해 만드는 방법






< ------------------------------------------------------------ JSP의 코드 블록 ------------------------------------------------------------>
* 출력문장 사이에 자바코드를 꽂아 넣는 몇가지 방법

* jsp 는 출력되어야 할 문장을 public void _jspService()함수에 출력할수있게 변환하고 쓰여짐 (지역변수 알고리즘) out.writer()로 감싸서
* 코드를 넣고 싶으면 <%%> 감싼다 >> 이것도 _jspService()함수에 들어감	>> 자바코드가 들어감
* y의 값은 : y에서 y의 값을 넣고 싶으면 ---> y의 값은 : <% out.print(y) %>	--- 변환----> out.write("y의 값은 : "); out.print(y);
	>> 문서내에서 특정 변수를 출력하고 싶으면 이를위한 코드블럭 존재 
	>> <%=y %> == out.print()와 같은 역할		
	(팁: write()는 문자열을 출력하기 위한 전문 함수, print()는 다양한 형태의 자료형을 출력할 수 있게하는 수많은 오버로드를 가진 메소드이다.)

* public int sum(int a, int b) { return a + b };
  > 이렇게 멤버메소드를 정의하고 싶을때는 <%%>을하면 _jspService()함수에 들어감 > 메소드안에 메소드를 정의 (자바에서는 불가능 > 구문 에러)
  > 원래 넣고싶은 위치는  public final class add_jsp {} 클래스에 넣고 싶음 
  >> <%! public int sum(int a, int b) { return a + b }; %> 이렇게 느낌표를 붙이면 멤버변수로 들어감

* page 지시자 (초기설정을 위한)
	<%@ page language="java" contentType="text/html: charset=UTF-8" pageEncoding="UTF-8" %>
	서블릿서 UTF-8로 출력하겠다 설정, 브라우저에게 알려주기 위한 내용을 직접 썼었음 (setCharacterEncoding(), setContentType())
	기존 함수를 코드블록 <%%>로 덮어서 사용하면 >> 이미출력이 지정된 뒤에 설정하고 있다라는 오류가 발생됨 >> 이런 오류로 코드블록으로 해결이 안됨
	>> 지시자를 통해 쓰면 어떤 출력을 진행하는 코드보다 앞서서 설정이 진행되므로 인코딩, 컨텐트타입 설정시 지시자를 사용해야함

* 코드블록의 종류 정리
  1. <% %> : 자바 코드를 이용하기 위해 (write로 덮어지는걸 막음), jsp서비스 함수에 옮겨짐
  2. <%=변수 %> : 문서내 특정 변수를 출력하고 싶을떄 사용 <% out.print(변수명); %>의 수고를 덜어줌
  3. <%! %> : _jspService()함수가 아닌 멤버 메소드로서 선언하고 싶을때 사용됨 add_jsp 클래스에 삽입됨
  4. <%@ $> : 페이지 지시자, 어떤 출력코드보다 먼저 인코딩을 설정하거나 컨텐트 타입 설정시 지시자를 이용해야함






< ------------------------------------------------------------ JSP의 내장객체 간단히 알아보기 ------------------------------------------------------------>
* jsp 페이지에서 int page 변수를 선언하면 : 로컬변수가 중복되었다 오류 발생
	> 코드블럭 외에 코드가 있다는걸 간과하면 안됨 jasper가 만든 서블릿은 내가 모르는 변수가 있을수 있음
	> jasper는 서비스 함수를 만들며 자신이 필요한 변수를 만들어놓음 : 그중 하나가 page
	> Jasper에 의해 마련된 변수들은 하나같이 객체를 가리키는 객체형식임 : 이런 변수들을 내장 객체라고 한다(Built in 객체)
	> 이런 변수가 있다는것을 알고 있어야하고, jsp에서 코드블럭만들때 내장객체들을 적절히 활용해서 코드를 만들 수 있어야함

* 내장객체 종류
	입출력도구: response, request 객체
	상태저장도구: applicaiton, session 객체
	페이지 내에서 세션, 어플리케이션처럼 임시로 데이터를 저장할수있는 도구 : pageContext (setAttribute, getAttribute가짐)
	>> servletContext는 전역적으로 사용한다면 pageContext는 _jspService내부에서만 쓰는 저장소
	
	config : servletConfig
	out  : 출력도구
	page  : page의 객체를 참조하는 Object형 페이지 변수


* 내장객체란 jasper가 만들어낸 서블릿 안에있는 미리 선언된 변수, 그것을 이용해 코드블럭에서 사용가능






< ------------------------------------------------------------  JSP로 만드는 Hello 서블릿 ------------------------------------------------------------>
nana.jsp 및 nana.java 참조






< ------------------------------------------------------------  스파게티 코드를 만드는 JSP ------------------------------------------------------------>
* 순서가 맞으면 여러 코드블록으로 나눠도 되고 합쳐도됨 ----> 이렇게 나뉘면 자바코드만 모아서 보기 어려움 -----> 어떤 블럭이 어디서 오류가 나고 어떤 역할을 하는지 찾기 쉽지 않음----> 스파게티 코드






< ------------------------------------------------------------  JSP MVC model1 ------------------------------------------------------------>
* JSP를 잘못만들면 --> 코드블럭이 복잡해짐 --> 어떻게 쉽게 만들어야 할까? --> MVC model1 --코드는 가능하면 위에 모아놓고 밑에는 출력코드만 모아놓음

* 따라서 입력코드블럭에서 만드는 결과물을 출력코드블록으로 이어주는 변수가 필요함 --> 이런 변수가 MODEL임 --> 블럭을 한곳에 모아놓는 방법은? ---> 출력코드는 <%=변수%>만 두고 나머지 제어블록들은 모두 입력코드로 보냄
  --> 출력할 데이터를 미리 만들고 출력코드에서 출력만 하면 코드가 깔끔해짐 --> 제어라는것을해서 출력을 위해 만들어낸 데이터 == model이라고 부름

* 입력과 제어를 담당 (출력할 데이터를 만들어내는 과정) 
  > Controller (자바코드)

* 출력데이터를 가져다 쓰는 부분 (출력부분)
  > View (html코드)

* controller(입력과 제어를 담당하는곳)에서 만든 결과물 == 출력할 데이터
  > Model

>> MVC 모델 (자바코드와 출력코드를 최대한 분리시키자)







< ------------------------------------------------------------  JSP MVC model1을 model2 방식으로 ------------------------------------------------------------>
* Model1 : 컨트롤러와 뷰가 물리적으로 분리되지 않은 방식
* Model2 : Controller와 뷰를 물리적으로 분리 (View만 사용자 요청시 서블릿으로 만들어짐, Controller는 미리 컴파일해놓고 있기 때문에 실행속도 개선) >> 따로 유지관리 좋음

* 분리된 컨트롤러와 뷰를 연결하기 위해 Forwarding이 사용됨 (컨트롤러에서 뷰로 이전되며 흐름을 이어받아 코드 진행하는 것 == Forwarding)
  > Forwarding은 Dispatcher를 이용해 포워딩을 함
  > Controller와 View가 계속적으로 추가되면 Controller는 계속 dispatcher를 가지고 있다.(공통적인사항이 각자 가지며 늘어남)

* Dispatcher와 Controller의 분리 (공통적으로 쓰는 디스패처를 하나만 두고 Controller를 따로 모아 놓음)
* Controller는 POJO클래스로 서블릿이 아닌 일반 클래스로 만듦

* 사용자 요청이 들어오면 디스패쳐가 사용자 요청을 수반해 적절한 컨트롤러를 찾아서 수행하게 진행함
  > Controller는 로직에 해당되는 뷰를 적당하게 호출할 수 있도록 디스패쳐에게 관련내용을 알려주면 디스패쳐에서 그걸 가지고 호출함 (front controller)

* 일단 프론트컨트롤러는 제외하고 컨트롤러와 뷰만 분리된 형식으로 만들기 

  > 포워딩과 redirect의 차이
 	forward : 현재 작업한 내용을 이어갈 수 있게 공유하는것
	redirect : 현재 작업내용 공유 상관없이 새로운 요청

  > 포워딩 쓰기

	1.RequestDispatcher dispatcher = request.getRequestDispatcher("spage.jsp");
	  현재 spage라는 URL(@WebServlet매핑)이 있는데 요청이 들어오면 jsp로 요청을 전달하는 것
	  spage.jsp명만 넣는 이유는 URL상 같은 디렉토리에 있다고 생각하기 때문에 지정하지 않음

	2. dispatcher.forward(request, response);
 	  현재 작업한 내용을 spage.jsp로 넘어가면 내용을 이어줌 (jsp지만 결국 서블릿으로 변환됨)
	  jsp에서 쓰고 있는 request, response가 포워드시 전달된 것과 동일함
	  일을 이어갈 수 있음

 	3. result 값을 같이 넘겨줘야 하므로 
	  이때 사용되는 저장소 request임
	  (어떤 상태 저장하기 위한 저장소 내부객체)
		pageContext : 서블릿 페이지 내에서 혼자 사용함
		request : 포워드 관계에서 사용할 수 있는 저장소
		session : 현재 세션에서 공유될 수 있는 저장소
		application : 모든 페이지에서 공유될 수 있는 저장소
		cookie : 클라이언트에 저장하는 저장소 (서버상에서는 쿠키는 제외하고 총 4개임)
		https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=kimkwon429&logNo=220760918355 참조하기
	
	4. 그럼 실행은 어디서? >>> 무조건 컨트롤러에서 실행해야함 (컨트롤러에서 데이터를 만들기 때문이다)
	5. 하나 아쉬운점
		자바 코드블럭의 흔적이 남아있음
		<body>
		<!-- result == Model -->
			<%=request.getAttribute("result")%>
			입니다.
		</body>
	6. EL표기법을 이용해 해결






< ------------------------------------------------------------ View를 위한 데이터 추출 표현식 EL(Expression Language) ------------------------------------------------------------>
* JSP를 MVC 방식으로 만들때 요긴하게 쓰인다.
* EL은 지역변수를 이용하기 위한 목적이 아니라 applicaiotn, session, request, pageContext와 같은 저장소에 있는 값을 꺼내서 출력하는 목적이다.

						기존의 방식
<Controller>						<>			<view>
request.setAttribute("cnt", 50);						request.getAttribute("cnt")
						EL 표기법으로 변환		
request.setAttribute("cnt", 50);						${cnt}		>> "키"값만 쓰면 된다(변수명이 아니라)


						<리스트를 쓴다면?>
List list = new ArrayList() {"1", "test"...};					((List)request.getAttribute("list")).get(0)	// Object타입 반환하므로
request.setAttribute("list", list);						

						EL 표기법으로 변환
List list = new ArrayList() {"1", "test"...};					${list[0]}		// 자동적으로 타입변환을 해주고 get(0)을 배열처럼 사용가능 (Array(일반배열)도 동일 )
request.setAttribute("list", list);			


						<Map을 쓴다면?>
Map n = new HashMap("title", "제목");						((Map)request.getAttribute("n")).get("title")	// Object타입 반환하므로
request.setAttribute("n", n);						

						EL 표기법으로 변환
List list = new ArrayList() {"1", "test"...};					${n.title}		// 키와 value값이므로 .연산자를 이용해 불러옴 AttrName.MapKey
request.setAttribute("list", list);									








< ------------------------------------------------------------ EL의 데이터 저장소 ------------------------------------------------------------>

* ${cnt}라는 키워드는 request라 하는 저장소에 담겨있다고 말함
* 사실은 request저장소에서만 ${cnt}키워드를 검색하는것은 아님
* 실제로 서버상에 존재하는 사용가능한 저장소는 4개 (page(페이지 내에서 사용할 수 있는 서블릿 객체들을 모아놓음), request, session, application) 이것으로 데이터를 꺼내거나 저장함

* pageContext (하나의 JSP페이지에서 공유가능)
	jsp 파일에서 pageContext page = setAttribute();로 값을 세팅하면 그 페이지에서 사용가능 >> EL로도 쓸 수 있다.

* EL을 이용해 뽑아낼수있는 객체는 pageContext, request, session, application 어디에 담겨있는것도 뽑아낼 수 있다.

* 만약 4개의 저장소에 같은 키워드 값을 가진 값을 심으면? 어떻게 될까?
	>> 오류가 나지 않으므로 충돌이 나지 않는거고 이는 곧 우선순위가 있다.
* EL이 저장소를 찾는 우선순위 (먼저 찾게되면 뒤에있는 값을 뒤지지 않음)
	1. pageContext
	2. request
	3. sesison
	4. application
	>> 따라서 page, request에 둘다 있는 값을 꺼내고 싶으면 request값은 절대 못뽑음

* 이를 해결하기 위한 방법 scope (특정한 저장소에서만 값을 꺼내오는 키워드,한정자)
	>pageScope (page에서만 값을 꺼내옴)
	>requestScope (request에서만 값을 꺼내옴)
	>sessionScope (session에서만 값을 꺼내옴)
	>applicationScope (application에서만 값을 꺼내옴)
	ex) ${sessionScope.cnt}		(객체가 아니라 한정자다)
	>> 이는 객체가 아니라 한정자이다. (해당저장소 객체의 기능 쓸수없음)

* EL표기는 4대 저장소 외에도 쓸수있는 다양한 객체 존재
	param, paramValues, header, headerValues, cookie, initParam, pageContext
	> 사용방법
	parameter얻기위해선 : ${param.cnt}
	header 값얻기위해선 : ${header.host}
	header에서 변수명명규칙에 어긋나면 : ${header["host"]}
	
	>pageContext 사용방법
	<%=pageContext.getRequest().getMethod() %>	>>	${pageContext.request.method}
	(현재 request값을 받고 java>jsp로 넘겨줄때 방식이 post인지 get인지 반환)
	EL표기는 자바를 쓰는 느낌이 아니라 객체를 쓸수있게 해주기 위해
	getter를 쓰긴하지만 메소드 호출느낌을 없애기 위해 괄호와, get을 빼고 소문자로 바꿈









< ------------------------------------------------------------ EL 연산자 ------------------------------------------------------------>
[] .
()
not ! empty
* / div % mod
+ -
< > <= >= lt(lessThan) gt(greaterThan le ge
== != eq ne
&& and
|| or
? :

왜 굳이 두 종류의 연산자를 사용할까?
html은 <>를 가지고 있으므로 안에서 <,>를 쓰는것이 바람직하지 않다 (xhtml : xml기반 문서는 허용안할수도있음)
그냥 편한거 쓰다 쓸수없는 환경이면 바꿔쓰자~!

* empty 연산자
	${empty num} == ${num==null || num==""} (null이거나 빈문자면 참값 반환)
	반대의 동작을 원하면 not empty 이용
	3항연산자를 이용해서 같이 사용가능
	${empty param.n? '값이 비어있습니다.' : param.n }

* 만약 ${param.n / 2}
	문자열이라 오류?
	정수 나누기 정수라 소수점 떼어내기?
	실수?
  >> 정답은 실수로 나타남 만약 소수점을 떼어내고 정수로만 쓰고싶다? 좀 더 특별한 방법 필요 : JSTL






< ------------------------------------------------------------ JSP를 이용해서 자바 웹 프로그램 만들기 시작 ------------------------------------------------------------>
html > jsp로 변경하면 한글 깨짐 alt + enter >> 인코딩 변경해준다





< ------------------------------------------------------------ JDBC를 이용해 글 목록 구현하기, 자세한 페이지 구현하기 ------------------------------------------------------------>
* JDBC 드라이버 추가하기
	톰캣으로 배포해서 실행하므로 자바 프로젝트에 추가하는게 아니다
	웹에서 사용되는 라이브러리가 어딘가로 배포되어 실행되어야 하므로 라이브러리를 같이 가지고 가야함
	라이브러리를 같이 배포할 수 있도록 라이브러리를 포함시켜야함
	WEB-INF에 담아준다







< ------------------------------------------------------------ 자세한 페이지 MVC model1 방식으로 변경하기 ------------------------------------------------------------>
* 위에서 작성한 코드는 일명 스파게티 코드.. 자바 코드 블록이 이곳저곳 떨어져 있어서 가독성이 매우 떨어진다. >> 한번 꼬이면 전체 코드를 찾으면서 고쳐야함 >> 굉장히 어렵다.
	>> 이게 가능하려면 html에 꽂아넣을수있는 최소한의 변수를 만들고 데이터만 꽂아넣는 구조 >> MVC model 1이다 >> 물과 기름처럼 양분하는데 가장 큰 역할 == model(변수)
* HTML : View
* JAVA CODE : Controller



<<한번 짚고 가자 Servlet Annotation의 의미>>

잘못 답변 하신듯 합니다.. 질문의 내용은 list.jsp의 a태그에서 detail만 지정했는데 님이 말씀하신 왜 같은 경로의 detail.jsp가 아닌 com.newlecture.web.controller 패키지의 NoticeDetailController 컨트롤러가 정상적으로 먼저 호출되었는가? 일거에요.. 그 답변으로 실제 존재하지 않는 notice 경로에 detail 이 있다고 말씀하신 것이구요. detail.jsp라면 몰라도.. 저 분의 질문이 제가 이해한게 맞다면 .. NoticeDetailController 컨트롤러 페이지에 서블릿 어노테이션으로 매핑한 주소 @WebServlet("/notice/detail") 이것이 지정되어 있기 때문에 가상의 경로(강의 초반에 있습니다.)를 url로 매핑되어 있기 때문에
NoticeDetailController  컨트롤러의 url 상 주소는 @WebServlet("/notice/detail") 즉 /notice/detail 가 되는 것이죠. 그럼 list.jsp역시 notice의 경로에 있으니 detial.jsp가 아닌 'url'상의 경로 (실제 소스폴더 경로가 아님) 즉, NoticeDetailController  가 호출된 것입니다.
간단하게 설명 드리지 못해 죄송합니다..
정리드리면,
NoticeDetailController.java 파일의 웹서블릿어노테이션 = @WebServlet("/notice/detail") 이것을 url로 표현하면 => http://.../notice/detail
list.jsp는 detail.jsp를 먼저 호출하지 않고 NoticeDetailController 가 호출돼야 하므로 본인의 경로 /notice 는 생략하고 detail을 호출하므로 http://.../notice/detail 됩니다..
http://.../notice/detail = NoticeDetailController.java

출처 : https://www.youtube.com/watch?v=p2g7pB7SbYw&list=PLq8wAnVUcTFVOtENMsujSgtv2TOsMy8zd&index=56


< ------------------------------------------------------------ MVC model2 방식으로 변경하기 ------------------------------------------------------------>
* model1에선 model이란 녀석을 지역적으로 사용함 controller는 자바코드, view는 html이다 
* 지역적으로 사용했다는 의미는 하나의 페이지에서(하나의 함수)에서 mvc만 구현했었음

* model2는 이걸 나누겠다는 의미 (Controller(servlet), Model, View(JSP) ) >> 어떻게 보면 서블릿이 2개이므로 모델의 서블릿과 서블릿을 이어주는 방법과 서블릿에서 모델 값을 넘길때 공유방법이 필요함
* 나눠서 작성하면 복잡도가 높아질수도 있지만 나눠서 만드는 장점이 크면 만들 수있음
* 장점 : V,C의 개별적으로 유지관리 가능 (협업가능), 재사용의 용이성, 실행에도 용이성이 있는데 Controller를 떼어놓음으로서 (자바코드만있음) 미리 컴파일 가능해짐

* 따라서 Controller가 Model을 만들어 상태를 저장해서 View단 서블릿으로 넘겨주어야 하는데 이때 상태저장하기위한 객체
	1. pageContext	: 얘는 안됨
	2. request : 제일 적합함 request는 입력도구지만 저장도구로 쓸수있는 능력도 있다.
	3. session : 범위가 넓음
	3. application : 범위가 넓음

* JSPPrj에서 제대로 context root 를 '/'제대로 설정했다면 /의 의미는 webapp/ 경로를 나타낸다.
  따라서 Controller의 URL매핑을 /notice/detail로 두면 webapp/notice/detail에 있다고 생각할 수 있다.
  detail.jsp는 list.jsp가 선행되어야 id값을 받아서 게시물을 출력할 수 있으므로 먼저 선행해서 실행한다.
  list.jsp의 a태그의 href옵션은 detail.jsp?id=<%=rs.getInt("id")%>가 아니라 detail?id=<%=rs.getInt("id")%> 이렇게 Controller의 좌표를 넘겨주고
  Controller에서 Model값들을 request에 저장해 detail.jsp로 forward한다

